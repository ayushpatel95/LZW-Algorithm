# LZW-Algorithm
### Introduction
The Lempel–Ziv–Welch  (LZW)  algorithm is  a  lossless  data  compression  algorithm.  LZW  is  an  adaptive  compression  algorithm  that  does  not  assume  prior  knowledge  of  the  input  data  distribution.  This algorithm works well when the input data is sufficiently large and there is redundancy in the data.Two examples  of  commonly used  file  formats  that  use LZW  compression  are  the  GIF  image  format  served  from  websites  and  the  TIFF  image  format.  LZW  compression  is  also  suitable  for  compressing  text files, and is the algorithm in the compress Unix file compression utility. This algorithm has two steps: 1. Encoding/Compressing 2. Decoding/Decompressing The  interesting  thing  is  that  the  encoding  table,  or  dictionary, computed  during  the  encoding  process  does not need to be explicitly transmitted. It can be regenerated from the coded/compressed data.

You have to implement the LZW algorithm and demonstrate it with fixed bit-length coding. However, the bit length N should be a command line argument. In practice, even though you will be using an N-bit representation for your codes (where N <= 16), you will treat each code as a primitive data type. For example, in Java you can use a short (16 bits) or an int (32 bits) variable to store each code.

### 1.Encoding: - 
Implement the encoding algorithm. Initially print the encoded data as integers, so it is easy to debug your code. For the "abbbab" input from our example, the encoded data should be 97, 98, 257, 256. You can use this also as the input for the decoder initially.- The input will be an ASCII text file, whose name is specified as a command line argument, followed by  the  specified  bit  length  N.  For  our  example,  when  the  input  is  in  the  file  “input1.txt”  and  the  specified bit length is 12, the command line can be: java Encoder input1.txt 12.  - Each encoded output should be saved as 2 bytes in a file. For the given example, the encoded output of  97  98  257  256  should  be  saved,  in  16-bit  format,  as  00000000  01100001 00000000  01100010  00000001  00000001 00000001  00000000.  Note  that  each  block  is  a  byte.  In  Java,  you  can  use  the  UTF-16BE character encoding to write the integer output to file. -  The  output  filename  should  have  the  form  <Input  File  Name  without  extension>  +  “.lzw”. For  an  input file named “input1.txt”, the output file would be named “input1.lzw”.  If you are using Linux, you can use xxd -b <FileName> command to read the byte data in the output file,  or  you  can  use  online  tools  like  http://www.fileformat.info/tool/hexdump.htm  to  view  the  data  in  hexadecimal format. 
  
  
### 2.Decoding:- 
Implement the decoding algorithm. To test your decoder initially,  get the encoder's output directly as numbers.  For  our  example,  the  input  for  the  encoder  initially  will  be  97,  98,  257,  256  and  the  output from the decoder will be “abbbab”. -  Use  the  encoded  file  generated  by  the  encoder  as  the  input  to  the  decoder.  The  command  line  
5 arguments should be specified in the order: <Encoded File Name> <Bit Length>. For our example, this would be:  java Decoder input1.lzw 12.- Store the decoded output in a file named <File Name without extension> + "_decoded.txt". So for our example, the output of the decoder would be stored in the file “input1_decoded.txt”. If you are using Linux, you can use the ‘diff’ command to check whether the input file and output file have identical content. Example inputs and outputs will be provided on Canvas so you can ensure correctness of your output formats. You are responsible for testing the correctness of your programs.
